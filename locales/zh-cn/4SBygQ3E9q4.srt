1
00:00:00,500 --> 00:00:03,419
Gmail、Facebook、Snapchat、Twitter

2
00:00:03,419 --> 00:00:07,198
以及大多数的手机游戏都有一个共同点

3
00:00:07,200 --> 00:00:09,780
在某种程度上 它们都需要互联网连接

4
00:00:09,778 --> 00:00:11,669
才能从服务器获取数据

5
00:00:11,669 --> 00:00:15,060
即使简单的天气应用也要从网络获取信息

6
00:00:15,060 --> 00:00:16,679
从最一般的意义上来说 要让

7
00:00:16,678 --> 00:00:18,279
应用连接到互联网

8
00:00:18,280 --> 00:00:19,830
你需要两样东西

9
00:00:19,829 --> 00:00:22,719
客户端应用和 Web 服务器

10
00:00:22,719 --> 00:00:24,719
在这个天气应用中 此 Android 应用

11
00:00:24,719 --> 00:00:26,329
即是客户端应用

12
00:00:26,329 --> 00:00:27,929
服务器将是互联网上的一些

13
00:00:27,928 --> 00:00:30,869
提供最新天气信息的服务器

14
00:00:30,870 --> 00:00:34,770
OpenWeatherMap.org 就是这样的天气服务器的一个例子

15
00:00:34,770 --> 00:00:36,510
从事服务器工作的工程师

16
00:00:36,509 --> 00:00:38,347
被称为后端工程师

17
00:00:38,347 --> 00:00:39,888
他们使用的技术不同于

18
00:00:39,890 --> 00:00:42,651
Android 开发人员 比如像你

19
00:00:42,651 --> 00:00:44,400
这是因为你从事的是

20
00:00:44,399 --> 00:00:46,530
客户端应用上的代码工作

21
00:00:46,530 --> 00:00:48,590
作为在客户端应用进行编码的人员

22
00:00:48,590 --> 00:00:51,090
你需要决定如何将客户端应用上的数据

23
00:00:51,090 --> 00:00:52,904
与服务器上的数据进行同步

24
00:00:52,904 --> 00:00:54,570
你可能已经知道名为 Sunshine 的天气应用

25
00:00:54,570 --> 00:00:58,170
我们在之前的课程中使用过

26
00:00:58,170 --> 00:01:01,490
Sunshine 使用称为轮询的数据同步策略

27
00:01:01,490 --> 00:01:03,510
当我们谈论客户端-服务器通信时

28
00:01:03,509 --> 00:01:06,000
轮询是指持续 ping 服务器

29
00:01:06,000 --> 00:01:08,010
以查看是否有任何更新

30
00:01:08,010 --> 00:01:10,430
的行为

31
00:01:10,430 --> 00:01:12,990
如果你曾看到过应用使用 JobScheduler 或同步适配器

32
00:01:12,989 --> 00:01:15,329
连接到服务器 那么很有可能

33
00:01:15,328 --> 00:01:17,759
它使用的就是轮询策略

34
00:01:17,760 --> 00:01:20,190
例如在 Sunshine 中 JobScheduler 被用于

35
00:01:20,188 --> 00:01:23,218
与服务器同步 每三个小时一次

36
00:01:23,218 --> 00:01:26,098
对于像 OpenWeatherMap.org 的服务器

37
00:01:26,099 --> 00:01:28,069
也就是我之前提到的天气服务器

38
00:01:28,069 --> 00:01:30,004
这个策略可能是可接受的

39
00:01:30,004 --> 00:01:32,129
你可能知道服务器上的天气是

40
00:01:32,129 --> 00:01:34,409
每天在世界标准时间 (UTC) 午夜更新

41
00:01:34,409 --> 00:01:36,959
但我们来想想 Squawker

42
00:01:36,959 --> 00:01:39,719
我们的课程开发人员思维都比较活跃 并且不受

43
00:01:39,718 --> 00:01:41,788
时间表限制

44
00:01:41,790 --> 00:01:44,310
他们可以在一天中的任何时候发送 squawk

45
00:01:44,310 --> 00:01:46,600
只要他们有东西想分享

46
00:01:46,599 --> 00:01:48,569
那么如果你有这样一个非定期

47
00:01:48,569 --> 00:01:51,028
更新的服务器 你如何

48
00:01:51,030 --> 00:01:53,099
使用 JobScheduler 和轮询

49
00:01:53,099 --> 00:01:55,198
来确保用户几乎实时地

50
00:01:55,200 --> 00:01:56,519
获得 squawk？

51
00:01:56,519 --> 00:01:59,310
你可以让应用比如每大约 30 秒进行一次轮询

52
00:01:59,310 --> 00:02:02,850
看看服务器上是否有任何新的 squawk

53
00:02:02,849 --> 00:02:06,259
不过这在电池能耗方面来说效率非常低

54
00:02:06,259 --> 00:02:07,799
这是因为课程讲师

55
00:02:07,799 --> 00:02:09,460
都是非常忙的人

56
00:02:09,460 --> 00:02:12,250
即使他们的社交媒体生活很丰富

57
00:02:12,250 --> 00:02:14,818
也不会每 30 秒就发布消息

58
00:02:14,818 --> 00:02:16,798
这意味大多数时间

59
00:02:16,800 --> 00:02:19,620
ping 服务器都是在做无用功

60
00:02:19,620 --> 00:02:22,230
进行这样的网络连接会耗尽电池

61
00:02:22,229 --> 00:02:25,709
并且都是无用的网络 ping

62
00:02:25,710 --> 00:02:27,170
事实上 使用无线电

63
00:02:27,169 --> 00:02:29,460
可能是 Android 设备上

64
00:02:29,461 --> 00:02:31,950
最耗电的 Activity 之一

65
00:02:31,949 --> 00:02:33,959
每次使用无线电时

66
00:02:33,960 --> 00:02:36,210
你的设备都需要为无线电通电

67
00:02:36,210 --> 00:02:38,550
这一步尤其耗电

68
00:02:38,550 --> 00:02:41,670
相比之下 一次完成一堆网络 Activity 

69
00:02:41,669 --> 00:02:43,709
然后让无线电断电要好过

70
00:02:43,710 --> 00:02:48,450
持续每 30 秒一次启动无线电

71
00:02:48,449 --> 00:02:51,959
所以另一种选择是使用小于每 30 秒一次的

72
00:02:51,960 --> 00:02:54,670
频率 比如说一小时一次

73
00:02:54,669 --> 00:02:58,558
但是如果你每小时检查一次服务器中的新 squawk

74
00:02:58,560 --> 00:03:01,170
那你将只是每小时获得一次新消息

75
00:03:01,169 --> 00:03:03,599
而非实时

76
00:03:03,598 --> 00:03:05,818
记住 我们希望用户在 squawk 

77
00:03:05,818 --> 00:03:07,228
从服务器发出后的毫秒以内

78
00:03:07,229 --> 00:03:10,949
就收到消息 而不是一小时以后

79
00:03:10,949 --> 00:03:13,319
所以 每 30 秒或每一小时

80
00:03:13,318 --> 00:03:16,578
轮询一次都不是好的办法

81
00:03:16,580 --> 00:03:19,410
这就是为什么许多需要实时数据的应用

82
00:03:19,408 --> 00:03:22,530
使用所谓的推送而不是轮询

83
00:03:22,530 --> 00:03:24,598
推动策略背后的想法

84
00:03:24,598 --> 00:03:27,209
不是让你的客户端手机不断询问

85
00:03:27,210 --> 00:03:29,730
服务器是否有更新

86
00:03:29,729 --> 00:03:32,159
而是服务器负责在有新的信息时

87
00:03:32,158 --> 00:03:34,626
告知手机

88
00:03:34,627 --> 00:03:36,210
服务器可以决定在消息中

89
00:03:36,210 --> 00:03:38,010
发送什么信息

90
00:03:38,008 --> 00:03:40,078
客户端应用收到消息后

91
00:03:40,080 --> 00:03:43,050
由它本身来决定如何响应

92
00:03:43,050 --> 00:03:45,930
你可以按自己的意愿让客户端做出反应

93
00:03:45,930 --> 00:03:48,700
例如 对于 Squawker 当服务器发出消息

94
00:03:48,699 --> 00:03:50,250
说有新的 squawk 时

95
00:03:50,250 --> 00:03:51,625
它可以触发代码来保存

96
00:03:51,625 --> 00:03:55,508
单条 squawk、从服务器重新下载所有数据、

97
00:03:55,508 --> 00:03:59,518
触发整个数据库同步 或让手机

98
00:03:59,520 --> 00:04:02,580
发出较大的噪声 或者你想要的

99
00:04:02,580 --> 00:04:04,020
任何反应

100
00:04:04,020 --> 00:04:06,360
推送作为一个更新策略

101
00:04:06,360 --> 00:04:07,979
始终比轮询更省电

102
00:04:07,979 --> 00:04:10,020
但代价是你需要更改服务及和

103
00:04:10,020 --> 00:04:11,640
手机两者的代码

104
00:04:11,639 --> 00:04:13,829
要实现这一点 你需要

105
00:04:13,830 --> 00:04:16,439
能够控制服务器 或者

106
00:04:16,439 --> 00:04:17,879
有一个能够编写本课程中

107
00:04:17,879 --> 00:04:21,449
服务器端代码的朋友 而我就是那个朋友

108
00:04:21,449 --> 00:04:23,218
我已经为你写好了服务器端代码

109
00:04:23,220 --> 00:04:24,660
这样你就可以专心学习

110
00:04:24,660 --> 00:04:27,600
如何实施面向 Squawker 的客户端推送

111
00:04:27,600 --> 00:04:30,560
在看代码之前 我们先来快速做一个小测试

