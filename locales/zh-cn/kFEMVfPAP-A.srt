1
00:00:00,000 --> 00:00:04,000
在这个问题中 我们必须决定是否这些程序做了点事

2
00:00:04,000 --> 00:00:08,000
我们有一个列表 我们计算出一些解答

3
00:00:08,000 --> 00:00:14,000
如果加入调用过程 proc1 2 3 4 当我们执行程序时

4
00:00:14,000 --> 00:00:20,000
不管这段代码做了什么事 它的作用还是一模一样  就让我们开始吧

5
00:00:20,000 --> 00:00:22,000
第一个程序中 只有一行

6
00:00:22,000 --> 00:00:28,000
我们设定 p 的第一个值等于它的第二个值

7
00:00:28,000 --> 00:00:31,000
这会改变 p 的元素

8
00:00:31,000 --> 00:00:40,000
我的意思是 如果我们有列表 [1,2]  执行 proc1  会把它改变为 [2,2]

9
00:00:40,000 --> 00:00:45,000
很显然地 这会大大的影响代码的运作  所以这是不正确的

10
00:00:45,000 --> 00:00:48,000
这个有点儿麻烦 让我们一步一步来

11
00:00:48,000 --> 00:00:55,000
我们知道 p 是指向一个列表 假设它是 [1,2,3]

12
00:00:55,000 --> 00:01:01,000
现在 我们重新指定 p 指向

13
00:01:01,000 --> 00:01:03,000
p 的原始值连接列表 [1]

14
00:01:03,000 --> 00:01:07,000
这会建立一个新列表  因为这是 '+' 运算符对列表的运作方式

15
00:01:07,000 --> 00:01:09,000
我们要建立一个新列表

16
00:01:09,000 --> 00:01:12,000
现在 p 指向它我们没有对 p 做任何事情

17
00:01:12,000 --> 00:01:16,000
最重要的是 原始列表一直保持不变

18
00:01:16,000 --> 00:01:19,000
最后的结果是 这个选项是对的

19
00:01:19,000 --> 00:01:22,000
我们可以解决这个问题 如同前一个问题

20
00:01:22,000 --> 00:01:25,000
我们从变量 p 开始  p 指向一个列表

21
00:01:25,000 --> 00:01:29,000
然后 我们建立新变量 q  q 和 p 指向相同的物件

22
00:01:29,000 --> 00:01:35,000
我们在 p 中加入 3 这是相同的列表 最后我们移除 3

23
00:01:35,000 --> 00:01:39,000
最后的结果是 得到与之前相同的列表

24
00:01:39,000 --> 00:01:44,000
这里 我们建立了一个新列表称为 q 这是一个空列表  里面什么也没有

25
00:01:44,000 --> 00:01:48,000
p 不是空的 我们把从 p 移除的元素加入 q

26
00:01:48,000 --> 00:01:53,000
如果我们还记得 pop 会得到 p 的最后一个项目 并传回它

27
00:01:53,000 --> 00:01:56,000
这将移除 3 然后我们把它加到 q

28
00:01:56,000 --> 00:02:02,000
这会持续下去 直到 p 是空的  我们得到之前列表的反向列表

29
00:02:02,000 --> 00:02:05,000
我只是象征一下

30
00:02:05,000 --> 00:02:07,000
然后 我们翻转这个过程

31
00:02:07,000 --> 00:02:13,000
如果我再做一次刚才做的事 最后的结果是  我们得到原来的列表 我们有一个空列表

32
00:02:13,000 --> 00:02:15,000
虽然 这并不重要

33
00:02:15,000 --> 00:02:18,000
重点是 我们仍保有我们的原始列表

34
00:02:18,000 --> 00:02:21,000
这个选项是对的
