1
00:00:00,412 --> 00:00:02,120
我们要构建的下一个组件

2
00:00:02,120 --> 00:00:04,610
是 Geofence Request 对象

3
00:00:04,610 --> 00:00:07,919
回到我们的代码 在 Geofencing.java 类中

4
00:00:07,919 --> 00:00:09,740
我们将添加一个私有辅助方法

5
00:00:09,740 --> 00:00:12,169
叫作 getGeofencingRequest 它

6
00:00:12,169 --> 00:00:14,689
使用 GeofencingRequest.Builder

7
00:00:14,689 --> 00:00:18,449
方法来构建我们的地理围栏请求

8
00:00:18,449 --> 00:00:21,019
在构建地理围栏请求时

9
00:00:21,019 --> 00:00:24,410
你需要指定一个叫做初始触发器的东西

10
00:00:24,410 --> 00:00:26,269
此触发器用于定义当设备已在

11
00:00:26,269 --> 00:00:28,730
我们将注册的任何地理围栏中时

12
00:00:28,730 --> 00:00:30,830
会发生的情况

13
00:00:30,829 --> 00:00:32,390
在这里 我将初始触发器设置

14
00:00:32,390 --> 00:00:35,509
为常量 initial_trigger_enter

15
00:00:35,509 --> 00:00:37,699
它的基本意思是如果在注册时

16
00:00:37,700 --> 00:00:40,160
设备已处于地理围栏内

17
00:00:40,159 --> 00:00:43,669
则立即触发入口转换事件

18
00:00:43,670 --> 00:00:45,859
我可以使用的另一个选项

19
00:00:45,859 --> 00:00:49,820
是 initial_trigger_dwell 它会仅在

20
00:00:49,820 --> 00:00:51,890
设备处于地理围栏内一段时间后

21
00:00:51,890 --> 00:00:54,259
触发入口事件

22
00:00:54,259 --> 00:00:56,359
然后为了完成地理围栏请求

23
00:00:56,359 --> 00:00:59,119
我们将地理围栏添加到我们重新创建的 ArrayList 中

24
00:00:59,119 --> 00:01:02,449
然后使用 Builder.build 构建它

25
00:01:02,450 --> 00:01:05,540
要创建我们的下一个组件 Pending Intent

26
00:01:05,540 --> 00:01:07,670
我们需要先创建和扩展

27
00:01:07,670 --> 00:01:09,963
BroadcastReceiver 类

28
00:01:09,963 --> 00:01:11,879
首先在项目中 创建一个名为

29
00:01:11,879 --> 00:01:14,780
GeofenceBroadcastReceiver 的类

30
00:01:14,780 --> 00:01:17,870
我已经直接在这里创建和设置好了

31
00:01:17,870 --> 00:01:20,570
在 GeofenceBroadcastReceiver 内 我们

32
00:01:20,569 --> 00:01:23,239
覆盖 onReceive 方法

33
00:01:23,239 --> 00:01:27,140
现在我们在这里要做的只是记录消息

34
00:01:27,140 --> 00:01:29,570
由于我们在扩展 BroadcastReceiver 类

35
00:01:29,569 --> 00:01:33,659
我们需要在清单文件中添加一个新的 receiver 标签

36
00:01:33,659 --> 00:01:37,409
GeofenceBroadcastReceiver 部分到这里就完成了

37
00:01:37,409 --> 00:01:39,369
现在回到我们的 Geofencing 类

38
00:01:39,370 --> 00:01:41,750
我们将需要创建一个辅助方法 叫作

39
00:01:41,750 --> 00:01:44,569
getGeofencePendingIntent 这将为我们创建 Pending

40
00:01:44,569 --> 00:01:46,369
Intent

41
00:01:46,370 --> 00:01:48,109
所以在这个方法中 我们将首先为

42
00:01:48,109 --> 00:01:50,599
GeofenceBroadcastReceiver 类创建一个

43
00:01:50,599 --> 00:01:51,799
intent

44
00:01:51,799 --> 00:01:55,159
而 PendingIntent.getBroadcast 方法

45
00:01:55,159 --> 00:01:57,259
用于创建 Pending Intent

46
00:01:57,260 --> 00:02:00,050
我们也可以缓存这个 Pending Intent 以重用它

47
00:02:00,049 --> 00:02:02,219
而不是每次都要创建一个新的

48
00:02:02,219 --> 00:02:02,719
完美

49
00:02:02,719 --> 00:02:04,310
现在设置好所有这些后 我们

50
00:02:04,310 --> 00:02:08,180
要将它们放在一起 并注册我们的地理围栏

51
00:02:08,180 --> 00:02:10,300
我们使用一个新的公有方法

52
00:02:10,300 --> 00:02:14,207
叫作 registerAllGeofences

53
00:02:14,206 --> 00:02:16,039
我要将此代码添加到

54
00:02:16,039 --> 00:02:18,709
Geofencing 类的顶部

55
00:02:18,710 --> 00:02:21,890
在 registerAllGeofences 内 我们首先进行一些

56
00:02:21,889 --> 00:02:24,979
完整性检查 以确保我们的 Google API 客户端已

57
00:02:24,979 --> 00:02:26,840
实际连接 并且我们

58
00:02:26,840 --> 00:02:28,729
有一些地理围栏要注册

59
00:02:28,729 --> 00:02:30,889
然后我们可以调用 LocationServices

60
00:02:30,889 --> 00:02:35,539
.GeofencingApi.addGeofences 传入客户端

61
00:02:35,539 --> 00:02:38,120
和我们两个辅助方法的结果：

62
00:02:38,120 --> 00:02:42,129
getGeofencingRequest 和 getGeofencePendingIntent

63
00:02:42,129 --> 00:02:44,419
我们要将 callback 类设为 this

64
00:02:44,419 --> 00:02:47,699
这意味着我们需要实现 ResultCallback 接口

65
00:02:47,699 --> 00:02:50,589
我在上面这里的类定义中这么做

66
00:02:50,590 --> 00:02:52,819
因为我实现了这个类

67
00:02:52,819 --> 00:02:57,099
我需要覆盖 onResult 对于 onResult 的设置

68
00:02:57,099 --> 00:03:00,000
我在这里记录了一条错误信息

69
00:03:00,000 --> 00:03:03,169
我们 Geofencing 类的全部设置差不多就要完成了

70
00:03:03,169 --> 00:03:05,259
但还需要在这里做一件事

71
00:03:05,259 --> 00:03:09,379
我们需要设置一个 unregisterAllGeofences 方法

72
00:03:09,379 --> 00:03:14,180
我要将它添加在 registerAllGeofences 下

73
00:03:14,180 --> 00:03:16,550
你可能注意到 unregisterAllGeofences

74
00:03:16,550 --> 00:03:19,780
实际上比 registerAllGeofences 稍简单

75
00:03:19,780 --> 00:03:23,810
这是因为它不需要地理围栏请求

76
00:03:23,810 --> 00:03:29,719
这里我们使用 LocationServices.GeofencingApi.removeGeofences

77
00:03:29,719 --> 00:03:33,109
删除使用特定 Pending Intent 创建的

78
00:03:33,110 --> 00:03:34,880
所有地理围栏

79
00:03:34,879 --> 00:03:36,949
最后一个方法设置好后 我们的 Geofencing.java 类

80
00:03:36,949 --> 00:03:39,619
就完成了

81
00:03:39,620 --> 00:03:43,849
这里我们提供了注册和取消注册

82
00:03:43,849 --> 00:03:48,169
地理围栏、更新地理围栏列表、

83
00:03:48,169 --> 00:03:51,019
创建地理围栏请求对象的方式

84
00:03:51,020 --> 00:03:55,490
以及设置一个方式来获取地理围栏 Pending Intent 对象

85
00:03:55,490 --> 00:03:58,040
现在我们可以将它们全部放在 MainActivity 中

86
00:03:58,039 --> 00:04:00,539
见证奇迹的发生了

87
00:04:00,539 --> 00:04:02,929
首先 在 MainActivity 中 我们需要

88
00:04:02,930 --> 00:04:05,300
在 onCreate 方法中创建 Geofencing 类

89
00:04:05,300 --> 00:04:08,310
的一个实例

90
00:04:08,310 --> 00:04:10,610
然后我们需要设置一个启用切换按钮

91
00:04:10,610 --> 00:04:13,400
以允许用户根据自己的意愿打开和关闭

92
00:04:13,400 --> 00:04:14,951
地理围栏

93
00:04:14,951 --> 00:04:16,910
我要将切换代码添加在这里 放在

94
00:04:16,910 --> 00:04:19,640
设置 RecyclerView 之后

95
00:04:19,639 --> 00:04:21,800
起始代码中已为你提供了

96
00:04:21,800 --> 00:04:23,300
切换的 UI

97
00:04:23,300 --> 00:04:25,189
但是 你仍然需要在 MainActivity 

98
00:04:25,189 --> 00:04:27,769
的 onCreate 方法中初始化

99
00:04:27,769 --> 00:04:29,130
切换按钮的状态

100
00:04:29,130 --> 00:04:31,129
你需要创建一个布尔 SharedPreference

101
00:04:31,129 --> 00:04:34,040
来记住这个状态 并确保切换按钮始终

102
00:04:34,040 --> 00:04:37,310
反映 SharedPreference 的值

103
00:04:37,310 --> 00:04:40,790
接下来我们需要设置 CheckedChangeListener

104
00:04:40,790 --> 00:04:43,410
以在每次切换按钮被打开或关闭时

105
00:04:43,410 --> 00:04:46,100
你获得更新的 SharedPreference 值

106
00:04:46,100 --> 00:04:49,160
以及根据该切换按钮的状态注册或取消注册

107
00:04:49,160 --> 00:04:52,070
所有地理围栏

108
00:04:52,069 --> 00:04:54,379
注意我还设置了一个私有成员

109
00:04:54,379 --> 00:04:56,810
叫做 mIsEnabled

110
00:04:56,810 --> 00:04:59,300
它可以使我之后在代码中追踪

111
00:04:59,300 --> 00:05:01,060
切换按钮的状态

112
00:05:01,060 --> 00:05:03,930
最后 要注册添加到列表中

113
00:05:03,930 --> 00:05:07,800
的任何新地点 在 RefreshPlacesData 中

114
00:05:07,800 --> 00:05:09,990
我要通过调用 updateGeofenceList 确保地理围栏列表

115
00:05:09,990 --> 00:05:13,410
处于最新状态 然后调用 

116
00:05:13,410 --> 00:05:17,910
registerAllGeofences（仅在切换按钮启用情况下）

117
00:05:17,910 --> 00:05:21,090
那么在这里的 RefreshPlacesData 中 我要将它添加在

118
00:05:21,089 --> 00:05:23,290
这里的 onResult 中

119
00:05:23,290 --> 00:05:23,790
非常棒

120
00:05:23,790 --> 00:05:25,090
现在全部都完成了

121
00:05:25,089 --> 00:05:27,539
我们来看看它能否正常运作

122
00:05:27,540 --> 00:05:30,890
但是等等 我们要怎样实际来测试它呢？

123
00:05:30,889 --> 00:05:32,736
这是不是意味着我们得出门呢？

124
00:05:32,737 --> 00:05:35,070
你知道吗 今天又是完美的

125
00:05:35,069 --> 00:05:36,159
加利福尼亚的一天

126
00:05:36,160 --> 00:05:38,640
我们可不想这样做

127
00:05:38,639 --> 00:05:41,399
好在我们有另一种方式

128
00:05:41,399 --> 00:05:44,221
来在下一个节点中伪造 GPS 信息

129
00:05:44,221 --> 00:05:46,470
我们会看到在不实际出门的情况下

130
00:05:46,470 --> 00:05:48,650
如何测试应用

