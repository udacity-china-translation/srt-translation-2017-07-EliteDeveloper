1
00:00:00,610 --> 00:00:03,069
这个问题要求你制作缓存

2
00:00:03,069 --> 00:00:05,401
并向你展示为什么我们需要缓存

3
00:00:05,402 --> 00:00:07,813
我要执行的程式码 是 40 而不是 100 

4
00:00:07,863 --> 00:00:10,475
但为 40 而不是 100

5
00:00:10,474 --> 00:00:14,064
让我们看看它花了多久的时间

6
00:00:14,064 --> 00:00:19,798
在它执行时 我们会看看执行缓存的程式码

7
00:00:19,798 --> 00:00:21,745
缓存的格式是什么样子呢

8
00:00:21,745 --> 00:00:24,304
它是一个字典

9
00:00:24,304 --> 00:00:29,260
key 的值是输入 与 key 相关的 value

10
00:00:29,260 --> 00:00:31,989
则是输出

11
00:00:31,989 --> 00:00:34,042
因此它将是 '输入/输出' 配对

12
00:00:34,042 --> 00:00:38,701
我们不想对于任何给定的输入 不止一次地执行程式码

13
00:00:38,701 --> 00:00:45,191
所以我们要做的是 检查输入是否在缓存中

14
00:00:45,191 --> 00:00:49,386
如果它不在缓存中 我们会把它加到缓存

15
00:00:49,386 --> 00:00:52,611
所以 我们现在准备传回它

16
00:00:52,610 --> 00:00:57,099
因此对于输入 我们传回缓存的值

17
00:00:57,100 --> 00:01:00,502
如果它不在里面 我们加入它 如果它在里面 我们只要传回它

18
00:01:00,502 --> 00:01:04,778
并让我们看看它是否执行 它执行地相当快

19
00:01:05,429 --> 00:01:09,382
现在我们回到没有缓存的版本

20
00:01:09,382 --> 00:01:14,544
对于输入值只为 40 的情况下执行看看

21
00:01:14,543 --> 00:01:17,855
而现在我们有了解决方案

22
00:01:17,855 --> 00:01:24,228
第 40 个 Search Results 斐波那契数字的答案就是这个计算结果

23
00:01:24,228 --> 00:01:25,001
cached-fibo 实际上是 Search Results 斐波那契数字

24
00:01:25,001 --> 00:01:27,447
你将在第六单元学到更多有关 Search Results 斐波那契数字

25
00:01:27,447 --> 00:01:30,420
第一个数字是答案

26
00:01:30,420 --> 00:01:34,716
第二个数字是计算该数字所花的秒数

27
00:01:34,716 --> 00:01:38,293
所以这没有使用缓存 现在让我们来看一看缓存

28
00:01:38,293 --> 00:01:42,999
在相同的版本使用缓存 我来执行它

29
00:01:42,001 --> 00:01:48,527
你可以看到 大约 0.1 毫秒就执行结束

30
00:01:48,527 --> 00:01:52,527
所以这里有巨大的差异 两分钟或 0.1 毫秒

