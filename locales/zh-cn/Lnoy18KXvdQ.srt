1
00:00:00,430 --> 00:00:03,510
答案如下 第一个选项始终等同 s 字符串

2
00:00:03,510 --> 00:00:06,550
记住在其左边什么内容也没有的情况下使用冒号的意思是什么  

3
00:00:06,550 --> 00:00:09,130
意思是从起始位置开始 

4
00:00:09,130 --> 00:00:11,220
当冒号右边什么内容也没有时 

5
00:00:11,220 --> 00:00:13,730
则说明是一直到末尾位置 因此当冒号左右两边都没有内容时 

6
00:00:13,730 --> 00:00:17,980
这说明选择了整个字符串 第二个选项略微复杂一些 

7
00:00:17,980 --> 00:00:21,542
但是这个选项也始终和 s 字符串的值保持一致 

8
00:00:21,542 --> 00:00:26,056
原因如下 这是原始 s 字符串 

9
00:00:26,056 --> 00:00:28,720
在其后面 我们加上另外一个 s 字符串 并对其通过0 冒号 -1+1进行索引 

10
00:00:28,720 --> 00:00:31,976
-1与1相加值为0 

11
00:00:31,976 --> 00:00:36,162
当通过0冒号0进行索引时 

12
00:00:36,162 --> 00:00:39,250
我们发现这是一个空字符串 之所以这是一个空字符串 

13
00:00:39,250 --> 00:00:41,930
是因为我们是从0开始 也是在0之前结束 

14
00:00:41,930 --> 00:00:44,400
0和0之间没有字符 

15
00:00:44,400 --> 00:00:47,310
因此这是一个空字符串 

16
00:00:47,310 --> 00:00:51,290
在 s 字符串的基础上加一个空字符串 结果还是原字符串 

17
00:00:51,290 --> 00:00:53,500
有趣的是当 s 为一个空字符串时 这仍然是说得通的 

18
00:00:53,500 --> 00:00:58,127
如果 s 是空字符串 s 通过0进行索引 

19
00:00:58,127 --> 00:01:01,750
就会产生错误 

20
00:01:01,750 --> 00:01:04,989
这是试图从 s 中选择第一个字符 

21
00:01:04,989 --> 00:01:07,480
然而 s 中并没有第一个字符 它是一个空字符串 

22
00:01:07,480 --> 00:01:11,252
但是 s 通过12 冒号 12 进行索引 

23
00:01:11,252 --> 00:01:13,490
即使 s 字符串中没有第12个字符 

24
00:01:13,490 --> 00:01:16,290
因为在这个索引区间没有字符 那也没有关系 

25
00:01:16,290 --> 00:01:19,590
我们来对空字符串进行评估 

26
00:01:19,590 --> 00:01:23,730
第三个选项也始终等于 s 

27
00:01:23,730 --> 00:01:26,180
它是从字符串的开始进行选择 从0开始 

28
00:01:26,180 --> 00:01:29,360
一直到结束 再一次 正如我们此处所见 

29
00:01:29,360 --> 00:01:31,920
即使 s 字符串没有字符 这也没有关系 

30
00:01:31,920 --> 00:01:34,430
我们会得到一个空字符串 如果 s 中有任何字符 

31
00:01:34,430 --> 00:01:37,410
我们会得到 s 字符串中的所有字符 

32
00:01:37,410 --> 00:01:41,530
这是第一个不等同于 s 字符串的选项 这个选项可能会有点奇怪 

33
00:01:41,530 --> 00:01:43,490
它就像是 选择从一开始到最后的所有字符 

34
00:01:43,490 --> 00:01:46,360
因为负1是 s 中最后一个字符的索引 

35
00:01:46,360 --> 00:01:50,400
但是需要注意的一点是这个选项选择的范围不包括最后一个字符 

36
00:01:50,400 --> 00:01:53,480
而实际 s 字符串的选择范围是每个字符 

37
00:01:53,480 --> 00:01:56,330
包括最后一个字符 

38
00:01:56,330 --> 00:01:59,210
我们在 Python 解释器中运行一下 

39
00:01:59,210 --> 00:02:03,320
我们输出 s 字符串 对冒号 负1进行索引之后的内容

40
00:02:03,320 --> 00:02:06,040
运行之后 我们会得到除了最后一个字符之外的所有字符 

41
00:02:07,380 --> 00:02:09,770
最后一个选项是最出乎意料的 

42
00:02:09,770 --> 00:02:13,630
这个选项始终等于 s  即使 s 包含的字符不足3个 

43
00:02:13,630 --> 00:02:17,050
该选项也始终等同于 s 因为选项的第一部分是

44
00:02:17,050 --> 00:02:18,320
选择从开头到第三个的字符 

45
00:02:18,320 --> 00:02:20,950
不包括第三个字符 

46
00:02:20,950 --> 00:02:24,010
随后我们在后面加上 s 从第三个到最后的所有字符

47
00:02:24,010 --> 00:02:27,120
如果 s 包含的字符少于3个 

48
00:02:27,120 --> 00:02:29,990
那这一部分就将成为空字符串 

49
00:02:29,990 --> 00:02:32,400
从第3个字符到最后没有字符 但是没有关系 

50
00:02:32,400 --> 00:02:34,450
我们会将空字符串加到第3个之前的字符中 

51
00:02:34,450 --> 00:02:37,470
我们来看一下它在 python 解释器中是如何运行的 

52
00:02:37,470 --> 00:02:41,570
我们将运行 s 字符串 从起始字符到第3个索引字符 

53
00:02:41,570 --> 00:02:45,160
并将这个 s 字符串加到从第3个索引字符开始到最后一个的字符串 s 上 

54
00:02:45,160 --> 00:02:50,670
最终运行得出的是一样的字符串 如果我们运行一个短一点的字符串 

55
00:02:50,670 --> 00:02:57,860
我们将 t 初始化为字符串 Hi 我们输出 t 字符串从起始字符到第3个位置的字符 

56
00:02:57,860 --> 00:03:03,510
加上 t 字符串从第3个字符到最后一个位置的字符 运行之后 我们没有收到错误提示 

57
00:03:03,510 --> 00:03:06,660
我们得到了 Hi 字符串 

58
00:03:06,660 --> 00:03:09,550
因此 这种索引子序列的方法适应性很好 

59
00:03:09,550 --> 00:03:12,050
即使我们索引的字符在字符串中并不存在 它仍可以运行 

60
00:03:12,050 --> 00:03:15,940
这种方法区别于从特定位置进行检索 

61
00:03:15,940 --> 00:03:19,360
如果我们检索 t 字符串的第3个字符 

62
00:03:19,360 --> 00:03:23,160
运行之后显示错误 

63
00:03:23,160 --> 00:03:25,283
因为在第3个位置没有字符 
