1
00:00:00,200 --> 00:00:03,460
递归定义同样适用于造词之外的其他问题

2
00:00:03,460 --> 00:00:06,110
递归定义可以应用于目前你在这门语言中所遇见的大部分场景

3
00:00:06,110 --> 00:00:07,689
但是接下来我们也要探讨怎么将这一概念用于

4
00:00:07,689 --> 00:00:10,550
制作过程 而且你也将看到怎么把递归定义应用在

5
00:00:10,550 --> 00:00:13,800
后面会介绍到的类 以及如何定义数据结构 有很多

6
00:00:13,800 --> 00:00:16,780
很多关于计算的问题都是出现递归定义的内容

7
00:00:16,780 --> 00:00:20,660
递归定义由两部分组成 它有一个基本情况

8
00:00:22,530 --> 00:00:24,660
在我们关于 word 的例子中 说的就是第二条造词规则

9
00:00:25,860 --> 00:00:27,360
对于这个基本情况我们可以把它看做一种

10
00:00:27,360 --> 00:00:31,330
定义的起点 而基本情况的重要性在于

11
00:00:31,330 --> 00:00:35,820
它不是按照 word 来定义 word 自身 它

12
00:00:35,820 --> 00:00:38,400
是我们已经明确了如何定义 word 的一种情况

13
00:00:38,400 --> 00:00:42,260
所以对于程序来说 基本情况的这一定义将会是

14
00:00:42,260 --> 00:00:45,540
输入量最少的 或者说是输入最简单的一种情况 也就是说

15
00:00:45,540 --> 00:00:47,280
我们通过基本情况的定义就可以得到 word 的具体内容 我们不需要

16
00:00:47,280 --> 00:00:50,900
做任何进一步的计算就可以得到 word 的内容 第二部分是

17
00:00:50,900 --> 00:00:54,240
递归情况 这种情况是按照 word 来对 word 自身做的定义

18
00:00:54,240 --> 00:00:57,570
[书写中]

19
00:00:57,570 --> 00:00:59,310
但是 word 并不能完全按照 word 自身来做定义

20
00:00:59,310 --> 00:01:01,660
它应该是按照

21
00:01:01,660 --> 00:01:03,880
某些基于 word 做出定义后的子版本做定义 我们需要

22
00:01:03,880 --> 00:01:06,040
继续进行定义的过程 直到最后关于基本情况的定义

23
00:01:06,040 --> 00:01:09,360
很快我们就会知道对于程序而言这意味着什么

24
00:01:09,360 --> 00:01:12,280
首先 我们将尝试通过其他一些例子来说明

25
00:01:12,280 --> 00:01:14,370
而不是按照程序来进行说明 这只是

26
00:01:14,370 --> 00:01:17,050
为了我们能够更好地理解如何通过递归的过程来实现更好的定义

