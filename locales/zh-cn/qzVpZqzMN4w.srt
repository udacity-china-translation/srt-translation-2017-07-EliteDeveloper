1
00:00:00,472 --> 00:00:01,929
在此练习中 我们将使用 Places API 的

2
00:00:01,929 --> 00:00:04,450
另一个方法 按 ID

3
00:00:04,450 --> 00:00:07,599
请求地点详情

4
00:00:07,599 --> 00:00:10,849
此方法是 getPlaceByID

5
00:00:10,849 --> 00:00:13,509
注意此方法需服从我们之前创建的 API

6
00:00:13,509 --> 00:00:16,030
监视的调用限制

7
00:00:16,030 --> 00:00:18,409
请查看此 Google Places 文档中的链接

8
00:00:18,408 --> 00:00:20,199
（我也在下面的讲师注释中提供了它）

9
00:00:20,199 --> 00:00:22,879
了解更多详情

10
00:00:22,879 --> 00:00:25,099
来看看我们如何在代码中使用它

11
00:00:25,100 --> 00:00:28,240
为了最大限度地减少 MainActivity 文件中的服务器调用

12
00:00:28,239 --> 00:00:32,439
我们需要创建一个称为 refreshPlacesData 的方法

13
00:00:32,439 --> 00:00:35,219
它会在单个调用中获取所有地点详情

14
00:00:35,219 --> 00:00:36,759
我将它的开头添加在

15
00:00:36,759 --> 00:00:40,059
onConnectionFailed 方法下

16
00:00:40,060 --> 00:00:44,140
首先清除所有本地存储的地点 ID

17
00:00:44,140 --> 00:00:47,140
然后使用这些 ID 创建一个字符串数组

18
00:00:47,140 --> 00:00:50,410
用于 getPlaceByID 调用

19
00:00:50,409 --> 00:00:52,419
接下来 要填写此列表 只需

20
00:00:52,420 --> 00:00:54,609
遍历从查询返回的游标

21
00:00:54,609 --> 00:00:57,280
并将每个 ID 添加到列表中

22
00:00:57,280 --> 00:01:03,760
接下来 调用 getPlaceByID 并传入 Google API 客户端

23
00:01:03,759 --> 00:01:05,469
我们还需要在将列表转换为

24
00:01:05,469 --> 00:01:08,480
数组后传入它

25
00:01:08,480 --> 00:01:11,630
注意我在这里使用了一个成员变量

26
00:01:11,629 --> 00:01:14,019
这意味着我们需要将 Google API

27
00:01:14,019 --> 00:01:17,679
客户端定义为一个成员变量 才能在此访问它

28
00:01:17,680 --> 00:01:20,410
我在上面这里声明其为成员变量

29
00:01:20,409 --> 00:01:23,500
现在回到 refreshPlacesData

30
00:01:23,500 --> 00:01:26,560
注意 getPlacesByID 方法会返回

31
00:01:26,560 --> 00:01:29,810
一个类型为 PlaceBuffer 的 PendingResult 

32
00:01:29,810 --> 00:01:33,100
PlaceBuffer 是一个 Places API 对象

33
00:01:33,099 --> 00:01:35,369
作为一个地点列表

34
00:01:35,370 --> 00:01:37,510
那么 要检索服务器的响应

35
00:01:37,510 --> 00:01:40,730
你需要为此 PendingResult 设置回调

36
00:01:40,730 --> 00:01:43,990
为满足这一点 我们创建一个新的结果回调

37
00:01:43,989 --> 00:01:47,049
并覆盖其中的 onResult 方法

38
00:01:47,049 --> 00:01:49,329
当服务器最终回复了地点

39
00:01:49,329 --> 00:01:51,670
详情后 它们将被包含在这个

40
00:01:51,670 --> 00:01:55,390
PlaceBuffer 参数中 即这里的 places

41
00:01:55,390 --> 00:01:57,825
我们想在这里做的是使用新信息

42
00:01:57,825 --> 00:01:59,199
更新 RecyclerView 这意味着

43
00:01:59,200 --> 00:02:02,490
我们需要对适配器做更多的更改

44
00:02:02,489 --> 00:02:05,140
那么我们跳到 PlaceListAdapter

45
00:02:05,140 --> 00:02:07,450
来进行这些更改

46
00:02:07,450 --> 00:02:10,120
在 PlaceListAdapter 中 我们需要添加

47
00:02:10,120 --> 00:02:12,610
一个类型为 PlaceBuffer 的新成员

48
00:02:12,610 --> 00:02:15,130
它将作为适配器的数据源

49
00:02:15,129 --> 00:02:18,280
我们称之为 mPLACES

50
00:02:18,280 --> 00:02:21,370
然后更新构造函数 使它取 PlaceBuffer

51
00:02:21,370 --> 00:02:24,730
然后使用它来设置 mPLACES

52
00:02:24,729 --> 00:02:28,479
接下来 我们需要修改 getItemCount 方法

53
00:02:28,479 --> 00:02:30,739
现在 getItemCount 需要返回

54
00:02:30,740 --> 00:02:35,409
mPLACES 中的项目数（只要不为 null）

55
00:02:35,409 --> 00:02:37,750
接下来我们将实现 onBindViewHolder

56
00:02:37,750 --> 00:02:40,629
来设置 TextView 显示 mPLACES 中特定位置

57
00:02:40,629 --> 00:02:45,310
的地点的名称与地址

58
00:02:45,310 --> 00:02:47,879
最后 我们需要一个 swapPlaces 方法

59
00:02:47,879 --> 00:02:51,430
它将像 CursorAdapter 中的 swapCursor 方法一样

60
00:02:51,430 --> 00:02:53,950
此方法会在列表中添加或更换了地点时

61
00:02:53,949 --> 00:02:57,099
将当前的 PlaceBuffer 替换为

62
00:02:57,099 --> 00:02:58,789
新的

63
00:02:58,789 --> 00:03:01,840
最后 要在 RecyclerView 中体现这些更改

64
00:03:01,840 --> 00:03:06,879
我们需要调用 this.notifyDataSetChanged

65
00:03:06,879 --> 00:03:10,719
现在 回到我们 MainActivity 中的 PendingResult 回调

66
00:03:10,719 --> 00:03:13,389
对于 getPlacesByID 调用

67
00:03:13,389 --> 00:03:16,569
我们在 onResult 中需要做的

68
00:03:16,569 --> 00:03:20,680
是将这个更新的 PlaceBuffer 传入我们

69
00:03:20,680 --> 00:03:25,490
创建的 swapPlaces 方法中 我们在这行中这么做

70
00:03:25,490 --> 00:03:27,760
我们来回顾一下目前为止所做的工作

71
00:03:27,759 --> 00:03:30,349
每当 refreshPlacesData 方法被调用

72
00:03:30,349 --> 00:03:32,530
它们将查询所有本地存储的地点 ID

73
00:03:32,530 --> 00:03:37,169
并使用它来调用 getPlaceByID

74
00:03:37,169 --> 00:03:40,119
getPlaceByID 从 Google 的实时服务器

75
00:03:40,120 --> 00:03:41,980
检索所有这些地点的详细信息

76
00:03:41,979 --> 00:03:44,259
当服务器回复了详细信息时

77
00:03:44,259 --> 00:03:46,780
适配器会交换 PlaceBuffer

78
00:03:46,780 --> 00:03:49,360
并使用从服务器检索的新地点

79
00:03:49,360 --> 00:03:51,490
刷新 RecyclerView

80
00:03:51,490 --> 00:03:54,805
那么我们实际什么时候需要调用 refreshPlacesData 呢？

81
00:03:54,805 --> 00:03:57,504
一个好的起点是在使用 PlacePicker

82
00:03:57,504 --> 00:04:00,009
添加了新地点后 也就是在

83
00:04:00,009 --> 00:04:02,799
ButtonClickEventHandler 中调用了 Insert 方法

84
00:04:02,800 --> 00:04:03,969
之后

85
00:04:03,969 --> 00:04:06,580
我们应仅调用 refreshPlacesData

86
00:04:06,580 --> 00:04:10,300
来反映 RecyclerView 中发生的变更

87
00:04:10,300 --> 00:04:13,260
另一个适合调用 refreshPlacesData 的地方

88
00:04:13,259 --> 00:04:15,429
是在建立 Google API 客户端

89
00:04:15,430 --> 00:04:17,209
连接之后

90
00:04:17,209 --> 00:04:19,540
我们在这里处理应用何时首次

91
00:04:19,540 --> 00:04:21,640
启动并成功连接 Google Play

92
00:04:21,639 --> 00:04:23,709
Services

93
00:04:23,709 --> 00:04:24,699
完美

94
00:04:24,699 --> 00:04:26,170
我们来运行一个测试 看看

95
00:04:26,170 --> 00:04:28,250
一切是否按期望运行

96
00:04:28,250 --> 00:04:30,730
现在当应用首次启动时 数据路中任何现有的

97
00:04:30,730 --> 00:04:33,879
地点 ID 将请求服务器获取更多详细信息

98
00:04:33,879 --> 00:04:36,509
并在其 RecyclerView 中显示

99
00:04:36,509 --> 00:04:39,120
而且 如果我使用 PlacePicker 添加新地点

100
00:04:39,120 --> 00:04:42,720
它会在之后立即出现在 RecyclerView 中

