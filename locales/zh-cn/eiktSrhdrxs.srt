1
00:00:00,000 --> 00:00:02,537
在论坛上关于哈希表

2
00:00:02,537 --> 00:00:04,400
我们有很多很棒的问题

3
00:00:04,400 --> 00:00:07,274
一个例子是学生 Baracha 提问：

4
00:00:07,274 --> 00:00:09,282
"Python 如何决定当字典成长变大时 

5
00:00:09,282 --> 00:00:11,599
要有多少“桶” (bucket) 呢?"

6
00:00:11,599 --> 00:00:13,550
这是一个重要的问题

7
00:00:13,550 --> 00:00:16,048
关于哈希表还有很多、很多有趣的事情

8
00:00:16,047 --> 00:00:18,147
但在第五单元我们没有谈到

9
00:00:18,147 --> 00:00:22,871
如果内存是免费、廉价、而且同样地快速

10
00:00:22,871 --> 00:00:24,736
无论你需要多少

11
00:00:24,736 --> 00:00:27,589
你宁愿哈希表越大越好 对吗?

12
00:00:27,589 --> 00:00:30,321
你会想要你的哈希表里有数十亿个“桶”

13
00:00:30,321 --> 00:00:32,685
然后在每个“桶”内 就不必储存一个以上的项目

14
00:00:32,685 --> 00:00:35,903
但正如我们在第三单元所见 内存可能很昂贵

15
00:00:35,904 --> 00:00:41,570
速度愈快而且愈接近处理器的内存

16
00:00:41,570 --> 00:00:43,353
它的费用也愈昂贵

17
00:00:43,353 --> 00:00:45,484
所以你的内存数量非常有限

18
00:00:45,484 --> 00:00:47,849
这是尽量保持哈希表小的原因

19
00:00:47,848 --> 00:00:49,564
这是一个艰难的权衡

20
00:00:49,564 --> 00:00:51,421
好的哈希表实作

21
00:00:51,421 --> 00:00:53,687
尝试为你做了权衡

22
00:00:53,688 --> 00:00:55,873
让你在性能和内存使用上 得到适当的平衡

23
00:00:55,872 --> 00:00:58,371
他们根据负载因数 (load factor) 来做权衡

24
00:00:58,371 --> 00:01:00,369
我们确实在第四单元使用它

25
00:01:00,369 --> 00:01:02,756
也就是“项目的数量”除以“桶数”

26
00:01:02,756 --> 00:01:10,703
我们在第五单元有一个问题 “N 除以 B”

27
00:01:10,703 --> 00:01:14,137
在问题中 你看到“桶数”和“项目的数量”变化所产生的影响

28
00:01:14,137 --> 00:01:18,486
当你做这件事时 你必须担心一件事

29
00:01:18,486 --> 00:01:20,623
如果你只看着“关键字数目”和“桶数”

30
00:01:20,623 --> 00:01:24,235
这是平均的大小 但在许多应用中的问题

31
00:01:24,236 --> 00:01:27,648
更重要的是“最坏的大小” 即使平均大小是相当小的

32
00:01:27,647 --> 00:01:30,415
“最坏的大小”可能会比这个大得多

33
00:01:30,415 --> 00:01:32,599
如果对于最坏情况的项目做查找开始变得很糟

34
00:01:32,599 --> 00:01:36,503
然后你会想要更多的“桶”

35
00:01:36,504 --> 00:01:38,805
或是以某种方式来改变你的 hash 函数

36
00:01:38,805 --> 00:01:40,818
所以 对于一个典型的哈希表实作

37
00:01:40,817 --> 00:01:43,596
通常目标是要让负载因数实际上小于 1

38
00:01:43,596 --> 00:01:46,238
对于 Python 的字典实作

39
00:01:46,239 --> 00:01:49,817
如果关键字的数量超过约 2/3

40
00:01:49,817 --> 00:01:53,686
我认为它实际上刚好是表的大小的 2/3

41
00:01:53,686 --> 00:01:55,903
这是表的大小重新做调整的点

42
00:01:55,903 --> 00:01:59,081
表会变成两倍大

43
00:01:59,081 --> 00:02:01,605
这会改变每个字所出现的“桶”

44
00:02:01,605 --> 00:02:03,572
因为我们之前看到哈希表的结果

45
00:02:03,572 --> 00:02:05,684
取决于你所拥有的“桶数”

46
00:02:05,685 --> 00:02:07,888
因此必须要将资料复制到新的哈希表

47
00:02:07,888 --> 00:02:11,200
新的哈希表有更多的空间 会使得查找速度更快

48
00:02:11,199 --> 00:02:14,864
也就是说 如果你在哈希表有大约 100 万个项目

49
00:02:14,865 --> 00:02:17,748
你会期待有 150 万个“桶”

50
00:02:17,747 --> 00:02:21,352
但当你增加到 2/3 的门槛值

51
00:02:21,353 --> 00:02:23,484
然后你要把“桶”的大小增为两倍

52
00:02:23,484 --> 00:02:25,169
所以你最后会有 300 万“桶” 

53
00:02:25,169 --> 00:02:27,264
如果你在 2/3 的门槛值上多加一个项目

54
00:02:27,264 --> 00:02:31,331
所以 如果你比较这个与我们在第五单元所做的

55
00:02:31,330 --> 00:02:33,281
你可能会惊讶它的负载因数是如此之低

56
00:02:33,282 --> 00:02:35,099
我们做的哈希表范例

57
00:02:35,098 --> 00:02:37,022
“桶数”非常小

58
00:02:37,022 --> 00:02:39,086
每“桶”有许多项目

59
00:02:39,086 --> 00:02:41,804
这部分是为了更容易看出到底是怎么回事

60
00:02:41,804 --> 00:02:44,081
因为如果你看到一个哈希表有上千个空“桶”

61
00:02:44,081 --> 00:02:46,316
那将很难列印出来

62
00:02:46,316 --> 00:02:48,822
但其他的原因是

63
00:02:48,822 --> 00:02:51,471
我们在第五单元实作哈希表的方式是每个“桶”是一个列表

64
00:02:51,471 --> 00:02:55,907
使用列表 这是一种相当昂贵的资料结构

65
00:02:55,907 --> 00:02:57,734
你得建立这些空列表

66
00:02:57,734 --> 00:02:59,403
才能建立你的哈希表

67
00:02:59,402 --> 00:03:01,490
Python 字典的实作方式

68
00:03:01,491 --> 00:03:03,056
只是一个扁平的列表

69
00:03:03,056 --> 00:03:05,347
这意谓着每个 hash 值只有一个空间

70
00:03:05,347 --> 00:03:08,052
如果 hash 到一个特定的“桶”

71
00:03:08,051 --> 00:03:09,806
只存在一个空间

72
00:03:09,806 --> 00:03:11,669
也就是说 如果两个物件 hash 到相同的“桶”

73
00:03:11,669 --> 00:03:13,419
你必须去做点别的事情

74
00:03:13,419 --> 00:03:15,203
Python 字典实作如何处理呢

75
00:03:15,204 --> 00:03:17,688
你需要另一个多余的地方来放置它

76
00:03:17,687 --> 00:03:20,168
你有方法来决定当第一个“桶”满了时

77
00:03:20,169 --> 00:03:22,073
到那里寻找下一个

78
00:03:22,073 --> 00:03:24,415
这使得查找和添加项目到表中 变得更为复杂

79
00:03:24,414 --> 00:03:26,199
这就是为什么我们没有这样做的原因

80
00:03:26,199 --> 00:03:28,182
但这也意谓着 使用较少的内存

81
00:03:28,182 --> 00:03:29,674
因为你不必为这些'空桶'

82
00:03:29,674 --> 00:03:31,417
存放这些空列表

83
00:03:31,417 --> 00:03:33,501
"Beautiful Code" 这本书中有一章很棒

84
00:03:33,501 --> 00:03:35,774
谈的是所有关于 Python 字典的实作

85
00:03:35,774 --> 00:03:37,568
所以 如果你对实际的实作感到兴趣

86
00:03:37,568 --> 00:03:40,253
我鼓励你看看这一章