1
00:00:00,000 --> 00:00:03,000
定义 find_element 还有很多其他方式

2
00:00:03,000 --> 00:00:07,000
下面我将展示一种方式 这种方式利用另一个内部的列表操作 

3
00:00:07,000 --> 00:00:11,000
我们尚未介绍这个操作 但是这大大简化了 find_element 的编写 

4
00:00:11,000 --> 00:00:14,000
这个操作叫做 index (索引) 

5
00:00:14,000 --> 00:00:16,000
index 方法在列表上被调用 

6
00:00:16,000 --> 00:00:22,000
你传入一个值 index 的输出是那个值存在于列表中的位置 

7
00:00:22,000 --> 00:00:26,000
所以这个内建 index 几乎完全按照我们的心意解决了 find_element 

8
00:00:26,000 --> 00:00:31,000
不同之处在于 当我们在列表上调用 index 而该列表不包含我们传入的值 

9
00:00:31,000 --> 00:00:35,000
index 不会返回 -1 而是显示 error (出错) 

10
00:00:35,000 --> 00:00:39,000
我们来看看 Python 解释器中的情况 

11
00:00:39,000 --> 00:00:45,000
我将定义一个变量 p 并传入列表0 1 2的值 

12
00:00:45,000 --> 00:00:50,000
如果我们调用 p.index() 传入2 我们得到的结果是2 

13
00:00:50,000 --> 00:00:54,000
也就是2这个值在 p 中的位置 

14
00:00:54,000 --> 00:00:57,000
第二个例子中 我们多加两个2到列表中 

15
00:00:57,000 --> 00:01:00,000
我们看到 它总是显示第一个2 

16
00:01:00,000 --> 00:01:06,000
所以 p.index 返回的结果是找到值2的第一个位置 

17
00:01:06,000 --> 00:01:09,000
现在我们将试着传入一个列表中不存在的元素 

18
00:01:09,000 --> 00:01:14,000
我们看到 结果不是 -1 而是显示出错 

19
00:01:14,000 --> 00:01:17,000
我们要找的目标元素在列表中不存在 

20
00:01:17,000 --> 00:01:21,000
所以 如果我们想让 find_element 完全按照要求行事 

21
00:01:21,000 --> 00:01:24,000
我们就不能直接使用 index 

22
00:01:24,000 --> 00:01:27,000
但还有其他一些可能很有帮助的列表操作 

23
00:01:27,000 --> 00:01:30,000
总结一下 index 方法的功能 

24
00:01:30,000 --> 00:01:36,000
如果传入的值存在于列表中 过程返回找到这个值的第一个位置 

25
00:01:36,000 --> 00:01:38,000
这正是我们想让 find_element 做的 

26
00:01:38,000 --> 00:01:42,000
问题在于 如果这个值在列表中找不到 过程就会显示出错 

27
00:01:42,000 --> 00:01:47,000
还有一个列表操作可以帮助我们使用 index 来编写 find_element 

28
00:01:47,000 --> 00:01:51,000
这种方法也对其他很多事情有帮助 那就是单词 in

29
00:01:51,000 --> 00:01:54,000
我们已经见过 in 被使用在 for 循环中 

30
00:01:54,000 --> 00:01:59,000
这里 我们使用同一个词 in 但是在这个语境下 它的意义有所不同 

31
00:01:59,000 --> 00:02:05,000
这个句法是在 in 的左边放一个值 in 后面跟一个列表 

32
00:02:05,000 --> 00:02:08,000
这个句法与我们之前见到的 Python 语言相比有些奇怪 

33
00:02:08,000 --> 00:02:13,000
它看起来不像一个方法调用 但是 在用英文对这个内容进行表达时 

34
00:02:13,000 --> 00:02:15,000
用它是非常自然的 

35
00:02:15,000 --> 00:02:18,000
如果我们说：3在列表中吗？

36
00:02:18,000 --> 00:02:21,000
我们用 Python 语言写出来就是3 in p 

37
00:02:21,000 --> 00:02:25,000
我们看看解释器中的情况 

38
00:02:25,000 --> 00:02:29,000
现在我打印出3 in p 的结果 

39
00:02:29,000 --> 00:02:32,000
3不在列表中 所以打印出来的为假 

40
00:02:32,000 --> 00:02:37,000
如果我把它改成2 in p 

41
00:02:37,000 --> 00:02:40,000
我们得到的值为真 

42
00:02:40,000 --> 00:02:43,000
总结一下 in 操作的功能 

43
00:02:43,000 --> 00:02:46,000
如果值存在于列表中 输出为真 

44
00:02:46,000 --> 00:02:48,000
反之为假 

45
00:02:48,000 --> 00:02:51,000
类似地 我们可以使用 not in 

46
00:02:51,000 --> 00:02:53,000
not in 正好与 in 相反 

47
00:02:53,000 --> 00:02:58,000
如果值不存在于列表中 那么 not in 列表结果的值为真 

48
00:02:58,000 --> 00:03:03,000
如果这个值存在于列表中 那么 not in 列表结果的值为假 

49
00:03:03,000 --> 00:03:10,000
〈value〉not in〈list〉完全等同于 not〈value〉in〈list〉

50
00:03:10,000 --> 00:03:15,000
采用 not in 的唯一原因是 在英文中 这比把 not 放在值和 in 之间

51
00:03:15,000 --> 00:03:19,000
读起来更顺一些 

52
00:03:19,000 --> 00:03:24,000
现在检查一些你是否理解了 index、in 和 not in 等操作 

53
00:03:24,000 --> 00:03:27,000
我想让你试着再次定义 find_element 函数

54
00:03:27,000 --> 00:03:31,000
它跟我们之前的定义功能一模一样 

55
00:03:31,000 --> 00:03:35,000
它会给出我们搜索的元素位置 如果该元素存在 

56
00:03:35,000 --> 00:03:38,000
如果不存在 它会显示 -1

57
00:03:38,000 --> 00:03:41,000
但是这次 不用 while 循环或 for 循环

58
00:03:41,000 --> 99:59:59,000
你试试看是否能够使用 index 来定义它 

