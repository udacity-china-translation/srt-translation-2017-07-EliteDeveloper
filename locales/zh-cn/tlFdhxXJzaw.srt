1
00:00:00,000 --> 00:00:03,000
家庭作业的第一个问题  我们必须决定所给的函数中

2
00:00:03,000 --> 00:00:06,000
那些与输入列表 p 成线性比例

3
00:00:06,000 --> 00:00:08,000
让我们一个一个地检查函数

4
00:00:08,000 --> 00:00:10,000
这应该看起来很熟悉

5
00:00:10,000 --> 00:00:15,000
sum-list 的功能就是输入列表 p  并计算 p 中数字的总和

6
00:00:15,000 --> 00:00:18,000
在这种情况下 最坏和最佳情况其实是相同的

7
00:00:18,000 --> 00:00:22,000
因为无论如何 你走过 for loop 次数为 p 的长度

8
00:00:22,000 --> 00:00:25,000
因此 如果你把 p 的项目增为两倍

9
00:00:25,000 --> 00:00:29,000
执行时间也增为两倍 因为你在这个 for loop 中

10
00:00:29,000 --> 00:00:31,000
要走遍两倍的项目

11
00:00:31,000 --> 00:00:37,000
所以 sum-list 的执行时间与列表 p 中的项目数 成线性比例

12
00:00:37,000 --> 00:00:41,000
这个程序决定输入的列表 p 中 是否有重复的元素

13
00:00:41,000 --> 00:00:43,000
让我们试个简单的例子

14
00:00:43,000 --> 00:00:46,000
这里是小列表 [0,1,1]

15
00:00:46,000 --> 00:00:50,000
经过这个程序码 我们有 i 和 j

16
00:00:50,000 --> 00:00:53,000
在 loop 的第一次运算中 i 和 j 都是 0

17
00:00:53,000 --> 00:00:56,000
也就是说 我们检查第一个元素 是否等于第一个元素

18
00:00:56,000 --> 00:01:02,000
这里的这个情况 这程序不比较与自己相同的元素

19
00:01:02,000 --> 00:01:06,000
所以增加 j 的值 现在我们比较第一个元素与第二个元素

20
00:01:06,000 --> 00:01:08,000
他们并不相同

21
00:01:08,000 --> 00:01:11,000
我们再做一次 比较第一个元素与第三个元素 他们也不相同

22
00:01:11,000 --> 00:01:14,000
然后我们增加 i 的值 把 j 值重设为 0

23
00:01:14,000 --> 00:01:18,000
0 和 1 不同

24
00:01:18,000 --> 00:01:20,000
1 和 1 不同

25
00:01:20,000 --> 00:01:27,000
最后 我们有 1 然后 2 在这里

26
00:01:27,000 --> 00:01:29,000
第二个元素和第三个元素相同 所以我们传回 True

27
00:01:29,000 --> 00:01:31,000
这就是工作原理

28
00:01:31,000 --> 00:01:35,000
现在 为了检查执行时间  这儿的关键部分是这两个 for loops

29
00:01:35,000 --> 00:01:38,000
对这个 for loop 我们大概要走的次数是 len(p) 次

30
00:01:38,000 --> 00:01:43,000
对 p 中的每个元素 我们也大概要走 len(p) 次

31
00:01:43,000 --> 00:01:47,000
这对于 p 的元素数目 形成了二次方的执行时间

32
00:01:47,000 --> 00:01:50,000
也就是说 如果 p 的元素的数目增为两倍

33
00:01:50,000 --> 00:01:55,000
整个程序的执行时间增为 4 倍

34
00:01:55,000 --> 00:01:57,000
这里是 mystery 函数

35
00:01:57,000 --> 00:02:00,000
你之前从没见过 但是应该熟悉这种普通结构

36
00:02:00,000 --> 00:02:02,000
这里我们有 while loop

37
00:02:02,000 --> 00:02:05,000
我们设 i 为 0 我们要继续这个 while loop

38
00:02:05,000 --> 00:02:07,000
直到 i 大于或等于 len(p)

39
00:02:07,000 --> 00:02:10,000
看着这里 我们基本上会逐一查看 p

40
00:02:10,000 --> 00:02:13,000
但我们要与平常的作法略有不同

41
00:02:13,000 --> 00:02:17,000
如果 p 指标 i 的元素是偶数

42
00:02:17,000 --> 00:02:19,000
我们要将 i 值增加 2

43
00:02:19,000 --> 00:02:22,000
否则  i 值增加 1

44
00:02:22,000 --> 00:02:26,000
所以在执行此函数的最坏情况是

45
00:02:26,000 --> 00:02:30,000
如果 p 中的每个元素是奇数

46
00:02:30,000 --> 00:02:35,000
也就是说 对于每次反覆运算  i 值只增加 1

47
00:02:35,000 --> 00:02:38,000
所以相对于 p 的每个元素是偶数

48
00:02:38,000 --> 00:02:40,000
我们只有一半的速度

49
00:02:40,000 --> 00:02:47,000
简化最坏的情况 我们有个 while loop   要走遍列表 p 的每个元素

50
00:02:47,000 --> 00:02:49,000
所以在最坏情况下 显然是线性的

51
00:02:49,000 --> 00:02:55,000
此外 我还注意到在最佳情况下  mystery 函数的执行时间也是线性的

52
00:02:55,000 --> 00:02:58,000
起初有些混乱 可能是因为它快一倍

53
00:02:58,000 --> 00:03:02,000
但我们的确聚焦在执行时间的成长

54
00:03:02,000 --> 00:03:07,000
即使它是最坏情况速度的两倍

55
00:03:07,000 --> 00:03:10,000
如果我们将列表 p 的元素数目增为两倍

56
00:03:10,000 --> 00:03:13,000
执行时间也增为两倍

