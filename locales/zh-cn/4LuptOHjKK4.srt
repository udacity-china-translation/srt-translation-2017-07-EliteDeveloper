1
00:00:00,000 --> 00:00:03,000
解决这个问题的方法有很多种 

2
00:00:03,000 --> 00:00:06,000
首先 我们来看看使用 while 循环的解决方法 

3
00:00:06,000 --> 00:00:08,000
我们将定义我们的 find_element 函数 

4
00:00:08,000 --> 00:00:13,000
我们将用 p 作为列表的名字 用 t 作为目标的名字 

5
00:00:13,000 --> 00:00:15,000
也就是我们想要匹配的元素 

6
00:00:15,000 --> 00:00:18,000
我们将定义这个循环来遍历 p 中所有元素 

7
00:00:18,000 --> 00:00:22,000
这跟我们之前见过的遍历列表的 while 循环相似 

8
00:00:22,000 --> 00:00:25,000
我们有一个 while 循环 我们已经引入了变量 i 

9
00:00:25,000 --> 00:00:27,000
我们将用它作为索引来遍历循环 

10
00:00:27,000 --> 00:00:32,000
while 循环停止的条件是当 i 达到 len(p) 

11
00:00:32,000 --> 00:00:36,000
所以我们要让 while 循环的判断为 i < len(p) 

12
00:00:36,000 --> 00:00:40,000
这个 while 循环的程序块中 我们要检查当前元素与 t 匹配 

13
00:00:40,000 --> 00:00:47,000
于是我们使用 p[i] 得到当前元素 接着用 == 来测试它是否等于 t 

14
00:00:47,000 --> 00:00:51,000
如果我们找到一个匹配 即找到两个相等的值 

15
00:00:51,000 --> 00:00:53,000
那么我们就要返回找到的索引 

16
00:00:53,000 --> 00:00:55,000
所以结果应为 i 的值 

17
00:00:55,000 --> 00:00:58,000
这就是我们找到匹配元素的索引 

18
00:00:58,000 --> 00:01:01,000
相对于使用 for 循环 使用 while 循环的风险在于

19
00:01:01,000 --> 00:01:06,000
你很容易忘记你需要增加所以变量 

20
00:01:06,000 --> 00:01:08,000
如果我们把循环就这样放着 它会永无休止地运行 

21
00:01:08,000 --> 00:01:13,000
因为如果找不到第一个匹配的元素 i 的值就永远不变 

22
00:01:13,000 --> 00:01:15,000
这样 我们就返回0 

23
00:01:15,000 --> 00:01:19,000
这个循环会不停继续下去 再次检查第一个元素 

24
00:01:19,000 --> 00:01:21,000
所以我们需要增加 i 的值 

25
00:01:21,000 --> 00:01:23,000
这就是 while 循环块的结尾 

26
00:01:23,000 --> 00:01:27,000
我们这样描述 find_element 过程应做什么 

27
00:01:27,000 --> 00:01:30,000
如果找不到元素 过程应返回－1 

28
00:01:30,000 --> 00:01:32,000
如果我们完成了 while 循环而没有返回 

29
00:01:32,000 --> 00:01:37,000
这意味着我们已经遍历了 while 循环所有 i 的值直至达到 len(p)-1 

30
00:01:37,000 --> 00:01:41,000
我们没有找到任何匹配的元素 所以我们应返回 -1 

31
00:01:41,000 --> 00:01:43,000
这就是定义 find_element 过程的一种方法 

32
00:01:43,000 --> 00:01:46,000
下面我将向你展示如何使用 for 循环来定义该过程 

33
00:01:46,000 --> 00:01:50,000
我们开始思考定义 find_element 时会更自然地想到使用 while 循环

34
00:01:50,000 --> 00:01:54,000
而不是 for 循环 是因为我们想从 find_element 返回的值

35
00:01:54,000 --> 00:01:56,000
是索引本身 

36
00:01:56,000 --> 00:01:59,000
当使用一个采用标准句法遍历循环中元素的 for 循环

37
00:01:59,000 --> 00:02:02,000
我们不追踪索引 

38
00:02:02,000 --> 00:02:04,000
我们看到的只有依次排列的各个元素 

39
00:02:04,000 --> 00:02:07,000
所以我们需要添加一些内容来追踪索引 

40
00:02:07,000 --> 00:02:09,000
因为索引是我们想要返回的值 

41
00:02:09,000 --> 00:02:12,000
所以我们仍然需要使用一个变量来追踪索引 

42
00:02:12,000 --> 00:02:16,000
我们将使用 i 作为变量 正如之前在 while 循环中的做法 

43
00:02:16,000 --> 00:02:19,000
现在我们有一个 for 循环 而不是 while 循环 

44
00:02:19,000 --> 00:02:22,000
在这里我们不需要考虑停止条件

45
00:02:22,000 --> 00:02:24,000
因为它只会遍历所有元素 

46
00:02:24,000 --> 00:02:29,000
与 while 循环主体相似 我们检查当前元素是否等于 t 

47
00:02:29,000 --> 00:02:32,000
在这个 for 循环中 我们可以通过使用变量 e 来得到当前元素 

48
00:02:32,000 --> 00:02:36,000
每次我们遍历循环主体时 

49
00:02:36,000 --> 00:02:38,000
当前元素就是这样被赋值的 

50
00:02:38,000 --> 00:02:41,000
我们的判断是使用 == 来比较 e 和 t 

51
00:02:41,000 --> 00:02:46,000
正如我们之前的 while 循环的做法 如果它们匹配 我们应返回结果 

52
00:02:46,000 --> 00:02:49,000
我们想要返回的结果是我们找到匹配的索引 

53
00:02:49,000 --> 00:02:51,000
在之前的 while 循环中 这点已经明确了 

54
00:02:51,000 --> 00:02:56,000
这很好理解 因为我们看的是元素 p 索引 i 

55
00:02:56,000 --> 00:03:00,000
在 for 循环中 我们必须更加注意 要知道那个索引在哪里 

56
00:03:00,000 --> 00:03:05,000
我们使用变量 i 来追踪那个索引 所以我们将返回 i 

57
00:03:05,000 --> 00:03:07,000
i 从0开始 

58
00:03:07,000 --> 00:03:09,000
每一次遍历循环我们都需要增加 i 

59
00:03:09,000 --> 00:03:12,000
所以 我们在遍历元素时追踪当前索引 

60
00:03:12,000 --> 00:03:16,000
正如在之前的定义中 我们使用 while 循环 

61
00:03:16,000 --> 00:03:20,000
如果到了结尾我们没有找到元素 那就意味着这个元素在 p 中不存在 

62
00:03:20,000 --> 00:03:22,000
我们应返回 - 1 

63
00:03:22,000 --> 99:59:59,000
在这个 for 循环中 我们同样这么做 

