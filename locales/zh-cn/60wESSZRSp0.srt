1
00:00:00,000 --> 00:00:04,000
这个问题里 我们要建立一个简单的数独检查

2
00:00:04,000 --> 00:00:09,000
在这个版本 我们有一个 n × n 矩阵 在这里 n 等于 3

3
00:00:09,000 --> 00:00:16,000
我们要确保每个数字每一列只出现一次 每一行只出现一次

4
00:00:16,000 --> 00:00:23,000
在这个例子中 1 在这列出现一次 这列出现一次 这列出现一次

5
00:00:23,000 --> 00:00:26,000
这行出现一次 这行出现一次 这行出现一次

6
00:00:26,000 --> 00:00:31,000
我们可以重复检查格子中的每一个数字

7
00:00:31,000 --> 00:00:33,000
下面是我们解决这个问题的行动计划

8
00:00:33,000 --> 00:00:36,000
我们要走遍每一个数字 从 1 到 n

9
00:00:36,000 --> 00:00:38,000
这里是从 1 到 3

10
00:00:38,000 --> 00:00:44,000
我们打算从 1 开始 我们打算同时走遍每一行和每一列

11
00:00:44,000 --> 00:00:49,000
检查数字在每一行每一列出现一次 而且只有一次

12
00:00:49,000 --> 00:00:54,000
在这里 我们看到 1 出现在第一行和第一列

13
00:00:54,000 --> 00:00:57,000
所以我们增加计数 1

14
00:00:57,000 --> 00:01:03,000
然后我们检查行与列中的第二个项目 然后是第三个项目

15
00:01:03,000 --> 00:01:06,000
在检查完行列中的每个项目

16
00:01:06,000 --> 00:01:11,000
我们检查我们的记数 并确保它两者都为 1

17
00:01:11,000 --> 00:01:15,000
如果其中一个不等于 1 那么这个格子是不正确的

18
00:01:15,000 --> 00:01:18,000
否则 如果我们走遍每一个数字

19
00:01:18,000 --> 00:01:22,000
看看每个数字在每一行每一列出现一次 而且只有一次

20
00:01:22,000 --> 00:01:27,000
那么这个格子符合我们修改后的数独特性 我们传回 True

21
00:01:27,000 --> 00:01:29,000
让我们来写程式

22
00:01:29,000 --> 00:01:32,000
这是完成后的程式码

23
00:01:32,000 --> 00:01:39,000
首先 我们求出格子的尺寸 只要简单的看一下 len(p)

24
00:01:39,000 --> 00:01:42,000
然后 我们开始第一个数字 走遍每一个数字

25
00:01:42,000 --> 00:01:46,000
同时检查每一行每一列

26
00:01:46,000 --> 00:01:50,000
对于行列中的每个项目 我们看看这个项目是否等于我们的数字

27
00:01:50,000 --> 00:01:53,000
如果是 我们增加计数 (count)

28
00:01:53,000 --> 00:01:55,000
否则 我们移动到下一个项目

29
00:01:55,000 --> 00:01:59,000
一旦我们走过该行和该列 我们会确保

30
00:01:59,000 --> 00:02:03,000
行数和列数都刚好是 1

31
00:02:03,000 --> 00:02:06,000
如果他们不是 1 我们就传回 False 并且停止

32
00:02:06,000 --> 00:02:09,000
因为格子违反了我们的数独特性

33
00:02:09,000 --> 00:02:13,000
否则 我们继续前进到下一行下一列

34
00:02:13,000 --> 00:02:15,000
直到我们已经走遍了每一行每一列

35
00:02:15,000 --> 00:02:18,000
完成了这个数字后 我们继续下一个数字

36
00:02:18,000 --> 00:02:22,000
我们走遍每一个数字 确保每个数字遵守数独特性

37
00:02:22,000 --> 00:02:25,000
我们传回 True 因为格子没有错误

38
00:02:25,000 --> 00:02:28,000
因此 它通过了测试