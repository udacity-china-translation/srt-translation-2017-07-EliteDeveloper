1
00:00:00,000 --> 00:00:09,000
对于这个问题 你要在列表中寻找最长、连续出现的元素

2
00:00:09,000 --> 00:00:13,000
在这种情况下是 5 因为这一行中有三个 5

3
00:00:13,000 --> 00:00:16,000
它在这一行中 比任何其他元素多

4
00:00:16,000 --> 00:00:22,000
有更多的 6 但他们是分开的 他们不是连续的

5
00:00:22,000 --> 00:00:25,000
我要以 '子列表' (sublist) 来谈论它

6
00:00:25,000 --> 00:00:30,000
我们在寻找最长、重复同一元素的 '子列表'

7
00:00:30,000 --> 00:00:35,000
为了做到这一点 我们要跟踪一些事情

8
00:00:35,000 --> 00:00:39,000
当我们进行时 我们必须跟踪最佳元素 (best_element)

9
00:00:39,000 --> 00:00:46,000
我们要跟踪包含最佳元素的 '子列表' 的长度

10
00:00:46,000 --> 00:00:51,000
当我们进行时 我们必须增加我们的计数

11
00:00:51,000 --> 00:00:54,000
如果找到的另一个元素与前一个相同

12
00:00:54,000 --> 00:00:57,000
对于 6  我们必须跟踪这个事实

13
00:00:57,000 --> 00:01:04,000
我们看着 6 而 6 正在出现 所以我们可以与这两个值做比较

14
00:01:04,000 --> 00:01:06,000
我要再引入两个变量

15
00:01:06,000 --> 00:01:11,000
我要引入目前 (current) 和目前长度 (current_length)

16
00:01:11,000 --> 00:01:16,000
要开始时 我们还没有任何信息 我们看着 7

17
00:01:16,000 --> 00:01:20,000
嗯 这就是我目前的数字 只有一个 好 我有一个 7

18
00:01:20,000 --> 00:01:25,000
这确实是最好的 因为我之前什么都没有 长度为一

19
00:01:25,000 --> 00:01:29,000
现在我们从 7 移动 来到 6 有一个 6

20
00:01:29,000 --> 00:01:35,000
再次移动 没有比以前更好 我们不会以 6 替换为 best_element

21
00:01:35,000 --> 00:01:40,000
现在我们来到第二个 6 —— 嗯 现在我们有两个 6

22
00:01:40,000 --> 00:01:43,000
这实际上比以前更好

23
00:01:43,000 --> 00:01:47,000
我打算更换 7 为 6  length 为 2

24
00:01:47,000 --> 00:01:50,000
我们没再得到 6 我们不会增加 6 的计数

25
00:01:50,000 --> 00:01:53,000
我们要开始新的计数为 5

26
00:01:53,000 --> 00:01:59,000
我们有一个 5、两个 5、三个 5 没有 5 了

27
00:01:59,000 --> 00:02:01,000
让我们与之前的 best_element 做比较

28
00:02:01,000 --> 00:02:09,000
只有两个 6  5 有 3 个 所以比较好 有较多的 5

29
00:02:09,000 --> 00:02:12,000
现在我们不再处理 5  我们再次处理 6

30
00:02:12,000 --> 00:02:16,000
有一个 6、 两个 6

31
00:02:16,000 --> 00:02:22,000
现在 我们比较 6 的数目与 5 的数目 6 不够多

32
00:02:22,000 --> 00:02:24,000
我们不会替换这里的值

33
00:02:24,000 --> 00:02:30,000
然后我们又到 7 有一个 7 再一次 我们不会替换这里的值

34
00:02:30,000 --> 00:02:34,000
我们的过程应该传回 5

35
00:02:34,000 --> 00:02:37,000
现在我们看一下代码来做到这点

36
00:02:37,000 --> 00:02:43,000
我们要定义一个过程 longest_repetition 输入是一个列表

37
00:02:43,000 --> 00:02:47,000
我们一开始时 不知道 best_element 是什么

38
00:02:47,000 --> 00:02:50,000
我要将它设定为 None length 为 0

39
00:02:50,000 --> 00:02:57,000
如果它是一个空列表 就不存在最长的重复 长度肯定是 0

40
00:02:57,000 --> 00:03:00,000
我们的 current —— 嗯 一个也没有

41
00:03:00,000 --> 00:03:02,000
长度也是 0

42
00:03:02,000 --> 00:03:09,000
我们要做什么？我们遍历输入列表中的所有元素

43
00:03:09,000 --> 00:03:11,000
我们要检查什么？

44
00:03:11,000 --> 00:03:17,000
让我们检查一下 看看 current 是否等于这个元素

45
00:03:17,000 --> 00:03:22,000
如果它不等于这个元素 我们使它等于这个元素

46
00:03:22,000 --> 00:03:28,000
让我们重设 current_length 为 1 因为我们现在获得一个元素

47
00:03:28,000 --> 00:03:30,000
所以它必须至少出现一次

48
00:03:30,000 --> 00:03:34,000
我们还不知道它是否会发生更多次 因为我们只检查到第一次

49
00:03:34,000 --> 00:03:38,000
我们在这个子列表 (sublist) 中已看到它

50
00:03:38,000 --> 00:03:44,000
如果 current 等于这个元素 长度的值要增加 1

51
00:03:44,000 --> 00:03:51,000
因为我们已经得到第二个 所以我们的子列表比之前的多 1

52
00:03:51,000 --> 00:03:58,000
在任一种情况下 我们想要检查这个元素的长度是否大于

53
00:03:58,000 --> 00:04:04,000
我们暂时储存为我们最佳 '子列表' 的长度

54
00:04:04,000 --> 00:04:10,000
如果它更好 我们要将 best_element 替换为 current

55
00:04:10,000 --> 00:04:14,000
我们要将 length 替换为 current_length

56
00:04:14,000 --> 00:04:23,000
所以当这些 for 循环执行完后 剩下要做的事就是传回 best_element

57
00:04:23,000 --> 00:04:26,000
这完成了代码

